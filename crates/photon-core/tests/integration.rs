//! Integration tests for photon-core.
//!
//! These tests exercise `ImageProcessor::process()` end-to-end without loading
//! any ML models (no SigLIP, no LLM). They verify that the core pipeline stages
//! (validate → decode → EXIF → hash → thumbnail) compose correctly and produce
//! a well-formed `ProcessedImage`.
//!
//! All tests use the shared fixtures at `tests/fixtures/images/`.

use photon_core::config::Config;
use photon_core::pipeline::DiscoveredFile;
use photon_core::{
    ImageProcessor, OutputFormat, OutputRecord, OutputWriter, PhotonError, PipelineError,
    ProcessOptions, ProcessedImage,
};
use std::path::{Path, PathBuf};

/// Resolve a fixture path relative to the workspace root.
fn fixture(name: &str) -> PathBuf {
    Path::new(env!("CARGO_MANIFEST_DIR"))
        .join("../../tests/fixtures/images")
        .join(name)
}

/// Return the fixtures directory.
fn fixtures_dir() -> PathBuf {
    Path::new(env!("CARGO_MANIFEST_DIR")).join("../../tests/fixtures/images")
}

// ---------------------------------------------------------------------------
// Full pipeline (no models)
// ---------------------------------------------------------------------------

#[tokio::test]
async fn full_pipeline_without_models() {
    let config = Config::default();
    let processor = ImageProcessor::new(&config);

    let result = processor
        .process(fixture("beach.jpg").as_path())
        .await
        .expect("beach.jpg should process successfully");

    // Core identification fields
    assert_eq!(result.file_name, "beach.jpg");
    assert_eq!(result.format, "jpeg");
    assert!(!result.content_hash.is_empty());
    assert_eq!(
        result.content_hash.len(),
        64,
        "BLAKE3 hex digest is 64 chars"
    );

    // Image dimensions and file size
    assert!(result.width > 0);
    assert!(result.height > 0);
    assert!(result.file_size > 0);

    // Thumbnail generated by default
    assert!(
        result.thumbnail.is_some(),
        "thumbnail should be generated by default"
    );

    // Perceptual hash generated by default
    assert!(
        result.perceptual_hash.is_some(),
        "perceptual hash should be generated by default"
    );

    // No models loaded → embedding and tags are empty
    assert!(result.embedding.is_empty(), "no embedding without model");
    assert!(result.tags.is_empty(), "no tags without model");

    // No LLM → no description
    assert!(result.description.is_none(), "no description without LLM");
}

// ---------------------------------------------------------------------------
// ProcessOptions: skip thumbnail
// ---------------------------------------------------------------------------

#[tokio::test]
async fn full_pipeline_skips_thumbnail() {
    let config = Config::default();
    let processor = ImageProcessor::new(&config);

    let options = ProcessOptions {
        skip_thumbnail: true,
        ..Default::default()
    };

    let result = processor
        .process_with_options(fixture("beach.jpg").as_path(), &options)
        .await
        .expect("should process with skip_thumbnail");

    assert!(
        result.thumbnail.is_none(),
        "thumbnail should be None when skipped"
    );
    // Other fields still populated
    assert!(!result.content_hash.is_empty());
    assert!(result.width > 0);
}

// ---------------------------------------------------------------------------
// ProcessOptions: skip perceptual hash
// ---------------------------------------------------------------------------

#[tokio::test]
async fn full_pipeline_skips_perceptual_hash() {
    let config = Config::default();
    let processor = ImageProcessor::new(&config);

    let options = ProcessOptions {
        skip_perceptual_hash: true,
        ..Default::default()
    };

    let result = processor
        .process_with_options(fixture("beach.jpg").as_path(), &options)
        .await
        .expect("should process with skip_perceptual_hash");

    assert!(
        result.perceptual_hash.is_none(),
        "perceptual hash should be None when skipped"
    );
    // Thumbnail still generated
    assert!(result.thumbnail.is_some());
}

// ---------------------------------------------------------------------------
// Multiple formats
// ---------------------------------------------------------------------------

#[tokio::test]
async fn process_multiple_formats() {
    let config = Config::default();
    let processor = ImageProcessor::new(&config);

    let cases = vec![
        ("test.png", "png"),
        ("beach.jpg", "jpeg"),
        ("dog.jpg", "jpeg"),
        ("car.jpg", "jpeg"),
    ];

    for (filename, expected_format) in cases {
        let result = processor
            .process(fixture(filename).as_path())
            .await
            .unwrap_or_else(|e| panic!("{filename} should process successfully: {e}"));

        assert_eq!(
            result.format, expected_format,
            "format mismatch for {filename}"
        );
        assert_eq!(result.file_name, filename);
        assert!(
            result.file_size > 0,
            "file_size should be > 0 for {filename}"
        );
    }
}

// ---------------------------------------------------------------------------
// Error: nonexistent file
// ---------------------------------------------------------------------------

#[tokio::test]
async fn process_nonexistent_file() {
    let config = Config::default();
    let processor = ImageProcessor::new(&config);

    let result = processor.process(Path::new("/nonexistent/image.jpg")).await;

    match result {
        Err(PhotonError::Pipeline(PipelineError::FileNotFound(path))) => {
            assert_eq!(path, PathBuf::from("/nonexistent/image.jpg"));
        }
        other => panic!("expected FileNotFound, got: {other:?}"),
    }
}

// ---------------------------------------------------------------------------
// Error: image dimensions exceed limit
// ---------------------------------------------------------------------------

#[tokio::test]
async fn process_rejects_oversized_dimensions() {
    let mut config = Config::default();
    // Set dimension limit to 1px — any real image will exceed this.
    config.limits.max_image_dimension = 1;

    let processor = ImageProcessor::new(&config);

    let result = processor.process(fixture("beach.jpg").as_path()).await;

    match result {
        Err(PhotonError::Pipeline(PipelineError::ImageTooLarge {
            width,
            height,
            max_dim,
            ..
        })) => {
            assert!(width > 1 || height > 1, "image should exceed 1px limit");
            assert_eq!(max_dim, 1);
        }
        other => panic!("expected ImageTooLarge, got: {other:?}"),
    }
}

// ---------------------------------------------------------------------------
// File discovery
// ---------------------------------------------------------------------------

#[tokio::test]
async fn discover_finds_fixtures() {
    let config = Config::default();
    let processor = ImageProcessor::new(&config);

    let files: Vec<DiscoveredFile> = processor.discover(fixtures_dir().as_path());

    // We have 4 fixture images
    assert_eq!(
        files.len(),
        4,
        "expected 4 fixtures, found: {:?}",
        files.iter().map(|f| &f.path).collect::<Vec<_>>()
    );

    // All expected files present
    let names: Vec<String> = files
        .iter()
        .map(|f| f.path.file_name().unwrap().to_string_lossy().to_string())
        .collect();

    for expected in &["test.png", "beach.jpg", "dog.jpg", "car.jpg"] {
        assert!(
            names.contains(&expected.to_string()),
            "missing fixture: {expected}"
        );
    }
}

// ---------------------------------------------------------------------------
// Output roundtrip: JSON
// ---------------------------------------------------------------------------

#[tokio::test]
async fn output_roundtrip_json() {
    let config = Config::default();
    let processor = ImageProcessor::new(&config);

    let original = processor
        .process(fixture("dog.jpg").as_path())
        .await
        .expect("dog.jpg should process");

    // Serialize to JSON
    let json = serde_json::to_string(&original).expect("serialize to JSON");

    // Deserialize back
    let restored: ProcessedImage = serde_json::from_str(&json).expect("deserialize from JSON");

    assert_eq!(original.file_name, restored.file_name);
    assert_eq!(original.content_hash, restored.content_hash);
    assert_eq!(original.width, restored.width);
    assert_eq!(original.height, restored.height);
    assert_eq!(original.format, restored.format);
    assert_eq!(original.file_size, restored.file_size);
    assert_eq!(original.embedding, restored.embedding);
    assert_eq!(original.tags.len(), restored.tags.len());
    assert_eq!(original.perceptual_hash, restored.perceptual_hash);
}

// ---------------------------------------------------------------------------
// Output roundtrip: JSONL via OutputWriter
// ---------------------------------------------------------------------------

#[tokio::test]
async fn output_roundtrip_jsonl() {
    let config = Config::default();
    let processor = ImageProcessor::new(&config);

    let img1 = processor
        .process(fixture("beach.jpg").as_path())
        .await
        .expect("beach.jpg");
    let img2 = processor
        .process(fixture("car.jpg").as_path())
        .await
        .expect("car.jpg");

    // Write as JSONL via OutputWriter
    let mut buf = Vec::new();
    {
        let mut writer = OutputWriter::new(&mut buf, OutputFormat::JsonLines, false);
        writer
            .write(&OutputRecord::Core(Box::new(img1.clone())))
            .expect("write img1");
        writer
            .write(&OutputRecord::Core(Box::new(img2.clone())))
            .expect("write img2");
        writer.flush().expect("flush");
    }

    let output = String::from_utf8(buf).expect("valid UTF-8");
    let lines: Vec<&str> = output.lines().collect();
    assert_eq!(lines.len(), 2, "JSONL should have 2 lines");

    // Parse each line back
    let r1: OutputRecord = serde_json::from_str(lines[0]).expect("parse line 1");
    let r2: OutputRecord = serde_json::from_str(lines[1]).expect("parse line 2");

    match (r1, r2) {
        (OutputRecord::Core(restored1), OutputRecord::Core(restored2)) => {
            assert_eq!(img1.content_hash, restored1.content_hash);
            assert_eq!(img2.content_hash, restored2.content_hash);
        }
        other => panic!("expected Core records, got: {other:?}"),
    }
}

// ---------------------------------------------------------------------------
// Deterministic hashing
// ---------------------------------------------------------------------------

#[tokio::test]
async fn deterministic_content_hash() {
    let config = Config::default();
    let processor = ImageProcessor::new(&config);

    let result1 = processor
        .process(fixture("beach.jpg").as_path())
        .await
        .expect("first run");
    let result2 = processor
        .process(fixture("beach.jpg").as_path())
        .await
        .expect("second run");

    assert_eq!(
        result1.content_hash, result2.content_hash,
        "content hash should be deterministic across runs"
    );
    assert_eq!(
        result1.perceptual_hash, result2.perceptual_hash,
        "perceptual hash should be deterministic across runs"
    );
}
