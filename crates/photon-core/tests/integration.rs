//! Integration tests for photon-core.
//!
//! These tests exercise `ImageProcessor::process()` end-to-end without loading
//! any ML models (no SigLIP, no LLM). They verify that the core pipeline stages
//! (validate → decode → EXIF → hash → thumbnail) compose correctly and produce
//! a well-formed `ProcessedImage`.
//!
//! All tests use the shared fixtures at `tests/fixtures/images/`.

use photon_core::{
    Config, DiscoveredFile, ImageProcessor, OutputFormat, OutputRecord, OutputWriter, PhotonError,
    PipelineError, ProcessOptions, ProcessedImage,
};
use std::path::{Path, PathBuf};

/// Resolve a fixture path relative to the workspace root.
fn fixture(name: &str) -> PathBuf {
    Path::new(env!("CARGO_MANIFEST_DIR"))
        .join("../../tests/fixtures/images")
        .join(name)
}

/// Return the fixtures directory.
fn fixtures_dir() -> PathBuf {
    Path::new(env!("CARGO_MANIFEST_DIR")).join("../../tests/fixtures/images")
}

// ---------------------------------------------------------------------------
// Full pipeline (no models)
// ---------------------------------------------------------------------------

#[tokio::test]
async fn full_pipeline_without_models() {
    let config = Config::default();
    let processor = ImageProcessor::new(&config);

    let result = processor
        .process(fixture("beach.jpg").as_path())
        .await
        .expect("beach.jpg should process successfully");

    // Core identification fields
    assert_eq!(result.file_name, "beach.jpg");
    assert_eq!(result.format, "jpeg");
    assert!(!result.content_hash.is_empty());
    assert_eq!(
        result.content_hash.len(),
        64,
        "BLAKE3 hex digest is 64 chars"
    );

    // Image dimensions and file size
    assert!(result.width > 0);
    assert!(result.height > 0);
    assert!(result.file_size > 0);

    // Thumbnail generated by default
    assert!(
        result.thumbnail.is_some(),
        "thumbnail should be generated by default"
    );

    // Perceptual hash generated by default
    assert!(
        result.perceptual_hash.is_some(),
        "perceptual hash should be generated by default"
    );

    // No models loaded → embedding and tags are empty
    assert!(result.embedding.is_empty(), "no embedding without model");
    assert!(result.tags.is_empty(), "no tags without model");

    // No LLM → no description
    assert!(result.description.is_none(), "no description without LLM");
}

// ---------------------------------------------------------------------------
// ProcessOptions: skip thumbnail
// ---------------------------------------------------------------------------

#[tokio::test]
async fn full_pipeline_skips_thumbnail() {
    let config = Config::default();
    let processor = ImageProcessor::new(&config);

    let options = ProcessOptions {
        skip_thumbnail: true,
        ..Default::default()
    };

    let result = processor
        .process_with_options(fixture("beach.jpg").as_path(), &options)
        .await
        .expect("should process with skip_thumbnail");

    assert!(
        result.thumbnail.is_none(),
        "thumbnail should be None when skipped"
    );
    // Other fields still populated
    assert!(!result.content_hash.is_empty());
    assert!(result.width > 0);
}

// ---------------------------------------------------------------------------
// ProcessOptions: skip perceptual hash
// ---------------------------------------------------------------------------

#[tokio::test]
async fn full_pipeline_skips_perceptual_hash() {
    let config = Config::default();
    let processor = ImageProcessor::new(&config);

    let options = ProcessOptions {
        skip_perceptual_hash: true,
        ..Default::default()
    };

    let result = processor
        .process_with_options(fixture("beach.jpg").as_path(), &options)
        .await
        .expect("should process with skip_perceptual_hash");

    assert!(
        result.perceptual_hash.is_none(),
        "perceptual hash should be None when skipped"
    );
    // Thumbnail still generated
    assert!(result.thumbnail.is_some());
}

// ---------------------------------------------------------------------------
// Multiple formats
// ---------------------------------------------------------------------------

#[tokio::test]
async fn process_multiple_formats() {
    let config = Config::default();
    let processor = ImageProcessor::new(&config);

    let cases = vec![
        ("test.png", "png"),
        ("beach.jpg", "jpeg"),
        ("dog.jpg", "jpeg"),
        ("car.jpg", "jpeg"),
    ];

    for (filename, expected_format) in cases {
        let result = processor
            .process(fixture(filename).as_path())
            .await
            .unwrap_or_else(|e| panic!("{filename} should process successfully: {e}"));

        assert_eq!(
            result.format, expected_format,
            "format mismatch for {filename}"
        );
        assert_eq!(result.file_name, filename);
        assert!(
            result.file_size > 0,
            "file_size should be > 0 for {filename}"
        );
    }
}

// ---------------------------------------------------------------------------
// Error: nonexistent file
// ---------------------------------------------------------------------------

#[tokio::test]
async fn process_nonexistent_file() {
    let config = Config::default();
    let processor = ImageProcessor::new(&config);

    let result = processor.process(Path::new("/nonexistent/image.jpg")).await;

    match result {
        Err(PhotonError::Pipeline(PipelineError::FileNotFound(path))) => {
            assert_eq!(path, PathBuf::from("/nonexistent/image.jpg"));
        }
        other => panic!("expected FileNotFound, got: {other:?}"),
    }
}

// ---------------------------------------------------------------------------
// Error: image dimensions exceed limit
// ---------------------------------------------------------------------------

#[tokio::test]
async fn process_rejects_oversized_dimensions() {
    let mut config = Config::default();
    // Set dimension limit to 1px — any real image will exceed this.
    config.limits.max_image_dimension = 1;

    let processor = ImageProcessor::new(&config);

    let result = processor.process(fixture("beach.jpg").as_path()).await;

    match result {
        Err(PhotonError::Pipeline(PipelineError::ImageTooLarge {
            width,
            height,
            max_dim,
            ..
        })) => {
            assert!(width > 1 || height > 1, "image should exceed 1px limit");
            assert_eq!(max_dim, 1);
        }
        other => panic!("expected ImageTooLarge, got: {other:?}"),
    }
}

// ---------------------------------------------------------------------------
// File discovery
// ---------------------------------------------------------------------------

#[tokio::test]
async fn discover_finds_fixtures() {
    let config = Config::default();
    let processor = ImageProcessor::new(&config);

    let files: Vec<DiscoveredFile> = processor.discover(fixtures_dir().as_path());

    // We have 4 fixture images
    assert_eq!(
        files.len(),
        4,
        "expected 4 fixtures, found: {:?}",
        files.iter().map(|f| &f.path).collect::<Vec<_>>()
    );

    // All expected files present
    let names: Vec<String> = files
        .iter()
        .map(|f| f.path.file_name().unwrap().to_string_lossy().to_string())
        .collect();

    for expected in &["test.png", "beach.jpg", "dog.jpg", "car.jpg"] {
        assert!(
            names.contains(&expected.to_string()),
            "missing fixture: {expected}"
        );
    }
}

// ---------------------------------------------------------------------------
// Output roundtrip: JSON
// ---------------------------------------------------------------------------

#[tokio::test]
async fn output_roundtrip_json() {
    let config = Config::default();
    let processor = ImageProcessor::new(&config);

    let original = processor
        .process(fixture("dog.jpg").as_path())
        .await
        .expect("dog.jpg should process");

    // Serialize to JSON
    let json = serde_json::to_string(&original).expect("serialize to JSON");

    // Deserialize back
    let restored: ProcessedImage = serde_json::from_str(&json).expect("deserialize from JSON");

    assert_eq!(original.file_name, restored.file_name);
    assert_eq!(original.content_hash, restored.content_hash);
    assert_eq!(original.width, restored.width);
    assert_eq!(original.height, restored.height);
    assert_eq!(original.format, restored.format);
    assert_eq!(original.file_size, restored.file_size);
    assert_eq!(original.embedding, restored.embedding);
    assert_eq!(original.tags.len(), restored.tags.len());
    assert_eq!(original.perceptual_hash, restored.perceptual_hash);
}

// ---------------------------------------------------------------------------
// Output roundtrip: JSONL via OutputWriter
// ---------------------------------------------------------------------------

#[tokio::test]
async fn output_roundtrip_jsonl() {
    let config = Config::default();
    let processor = ImageProcessor::new(&config);

    let img1 = processor
        .process(fixture("beach.jpg").as_path())
        .await
        .expect("beach.jpg");
    let img2 = processor
        .process(fixture("car.jpg").as_path())
        .await
        .expect("car.jpg");

    // Write as JSONL via OutputWriter
    let mut buf = Vec::new();
    {
        let mut writer = OutputWriter::new(&mut buf, OutputFormat::JsonLines, false);
        writer
            .write(&OutputRecord::Core(Box::new(img1.clone())))
            .expect("write img1");
        writer
            .write(&OutputRecord::Core(Box::new(img2.clone())))
            .expect("write img2");
        writer.flush().expect("flush");
    }

    let output = String::from_utf8(buf).expect("valid UTF-8");
    let lines: Vec<&str> = output.lines().collect();
    assert_eq!(lines.len(), 2, "JSONL should have 2 lines");

    // Parse each line back
    let r1: OutputRecord = serde_json::from_str(lines[0]).expect("parse line 1");
    let r2: OutputRecord = serde_json::from_str(lines[1]).expect("parse line 2");

    match (r1, r2) {
        (OutputRecord::Core(restored1), OutputRecord::Core(restored2)) => {
            assert_eq!(img1.content_hash, restored1.content_hash);
            assert_eq!(img2.content_hash, restored2.content_hash);
        }
        other => panic!("expected Core records, got: {other:?}"),
    }
}

// ---------------------------------------------------------------------------
// Edge case: zero-length file
// ---------------------------------------------------------------------------

#[tokio::test]
async fn process_zero_length_file() {
    let dir = tempfile::tempdir().expect("create temp dir");
    let empty_file = dir.path().join("empty.jpg");
    std::fs::write(&empty_file, b"").expect("create empty file");

    let config = Config::default();
    let processor = ImageProcessor::new(&config);
    let result = processor.process(empty_file.as_path()).await;

    assert!(result.is_err(), "empty file should fail to process");
    // 0-byte file fails in magic byte check (too small) → Decode error
    match result {
        Err(PhotonError::Pipeline(PipelineError::Decode { path, .. })) => {
            assert_eq!(path, empty_file);
        }
        other => panic!("expected Decode error, got: {other:?}"),
    }
}

// ---------------------------------------------------------------------------
// Edge case: 1x1 pixel image
// ---------------------------------------------------------------------------

#[tokio::test]
async fn process_1x1_pixel_image() {
    // Create a minimal 1x1 PNG in a temp file
    let dir = tempfile::tempdir().expect("create temp dir");
    let tiny_path = dir.path().join("tiny.png");
    let img = image::RgbImage::new(1, 1);
    img.save(&tiny_path).expect("save 1x1 PNG");

    let config = Config::default();
    let processor = ImageProcessor::new(&config);
    let result = processor
        .process(tiny_path.as_path())
        .await
        .expect("1x1 PNG should process successfully");

    assert_eq!(result.width, 1);
    assert_eq!(result.height, 1);
    assert_eq!(result.format, "png");
    assert!(!result.content_hash.is_empty());
    // Pipeline should still generate perceptual hash for tiny images
    assert!(result.perceptual_hash.is_some());
    // Thumbnail should be generated (even if trivially small)
    assert!(result.thumbnail.is_some());
}

// ---------------------------------------------------------------------------
// Edge case: corrupt JPEG header
// ---------------------------------------------------------------------------

#[tokio::test]
async fn process_corrupt_jpeg_header() {
    let dir = tempfile::tempdir().expect("create temp dir");
    let corrupt_path = dir.path().join("corrupt.jpg");
    // JPEG magic bytes followed by garbage
    std::fs::write(&corrupt_path, b"\xFF\xD8\xFF\x00GARBAGE_DATA_HERE").expect("write corrupt jpg");

    let config = Config::default();
    let processor = ImageProcessor::new(&config);
    let result = processor.process(corrupt_path.as_path()).await;

    assert!(result.is_err(), "corrupt JPEG should fail");
    match result {
        Err(PhotonError::Pipeline(PipelineError::Decode { path, message })) => {
            assert_eq!(path, corrupt_path);
            assert!(
                !message.is_empty(),
                "decode error should contain a descriptive message"
            );
        }
        other => panic!("expected Decode error, got: {other:?}"),
    }
}

// ---------------------------------------------------------------------------
// Edge case: unicode file path
// ---------------------------------------------------------------------------

#[tokio::test]
async fn process_unicode_file_path() {
    let dir = tempfile::tempdir().expect("create temp dir");
    let unicode_path = dir.path().join("日本語テスト画像.png");

    // Copy a real fixture to the unicode-named path
    let source = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../tests/fixtures/images/test.png");
    std::fs::copy(&source, &unicode_path).expect("copy fixture to unicode path");

    let config = Config::default();
    let processor = ImageProcessor::new(&config);
    let result = processor
        .process(unicode_path.as_path())
        .await
        .expect("unicode path should process successfully");

    assert_eq!(result.file_name, "日本語テスト画像.png");
    assert_eq!(result.format, "png");
    assert!(!result.content_hash.is_empty());
    assert!(result.width > 0);
    assert!(result.height > 0);
    assert!(result.file_size > 0);
}

// ---------------------------------------------------------------------------
// Deterministic hashing
// ---------------------------------------------------------------------------

#[tokio::test]
async fn deterministic_content_hash() {
    let config = Config::default();
    let processor = ImageProcessor::new(&config);

    let result1 = processor
        .process(fixture("beach.jpg").as_path())
        .await
        .expect("first run");
    let result2 = processor
        .process(fixture("beach.jpg").as_path())
        .await
        .expect("second run");

    assert_eq!(
        result1.content_hash, result2.content_hash,
        "content hash should be deterministic across runs"
    );
    assert_eq!(
        result1.perceptual_hash, result2.perceptual_hash,
        "perceptual hash should be deterministic across runs"
    );
}

// ---------------------------------------------------------------------------
// Boundary: file size at exact limit (F6)
// ---------------------------------------------------------------------------

#[tokio::test]
async fn test_file_size_at_exact_limit() {
    let dir = tempfile::tempdir().expect("create temp dir");
    let img_path = dir.path().join("at_limit.png");

    // Create a minimal valid PNG, then pad to exactly max_file_size_mb * 1024 * 1024 bytes
    let img = image::RgbImage::new(2, 2);
    img.save(&img_path).expect("save PNG");

    let mut config = Config::default();
    // Use 1 MB limit for test speed
    config.limits.max_file_size_mb = 1;
    let target_size = 1u64 * 1024 * 1024; // exactly 1 MB

    // Pad file to exactly the limit
    let current_size = std::fs::metadata(&img_path).unwrap().len();
    if current_size < target_size {
        let mut file = std::fs::OpenOptions::new()
            .append(true)
            .open(&img_path)
            .unwrap();
        use std::io::Write;
        let padding = vec![0u8; (target_size - current_size) as usize];
        file.write_all(&padding).unwrap();
    }
    assert_eq!(std::fs::metadata(&img_path).unwrap().len(), target_size);

    let processor = ImageProcessor::new(&config);
    let result = processor.process(img_path.as_path()).await;

    assert!(
        result.is_ok(),
        "file at exact size limit should succeed, got: {result:?}"
    );
}

// ---------------------------------------------------------------------------
// Boundary: file size one byte over limit (F6)
// ---------------------------------------------------------------------------

#[tokio::test]
async fn test_file_size_one_byte_over_limit() {
    let dir = tempfile::tempdir().expect("create temp dir");
    let img_path = dir.path().join("over_limit.png");

    let img = image::RgbImage::new(2, 2);
    img.save(&img_path).expect("save PNG");

    let mut config = Config::default();
    config.limits.max_file_size_mb = 1;
    let target_size = 1u64 * 1024 * 1024 + 1; // 1 byte over

    let current_size = std::fs::metadata(&img_path).unwrap().len();
    if current_size < target_size {
        let mut file = std::fs::OpenOptions::new()
            .append(true)
            .open(&img_path)
            .unwrap();
        use std::io::Write;
        let padding = vec![0u8; (target_size - current_size) as usize];
        file.write_all(&padding).unwrap();
    }
    assert_eq!(std::fs::metadata(&img_path).unwrap().len(), target_size);

    let processor = ImageProcessor::new(&config);
    let result = processor.process(img_path.as_path()).await;

    match result {
        Err(PhotonError::Pipeline(PipelineError::FileTooLarge { max_mb, .. })) => {
            assert_eq!(max_mb, 1);
        }
        other => panic!("expected FileTooLarge, got: {other:?}"),
    }
}

// ---------------------------------------------------------------------------
// Boundary: image dimension at exact limit (F6)
// ---------------------------------------------------------------------------

#[tokio::test]
async fn test_image_dimension_at_exact_limit() {
    let dir = tempfile::tempdir().expect("create temp dir");
    let img_path = dir.path().join("dim_at_limit.png");

    // Create image at exactly the dimension limit
    let img = image::RgbImage::new(100, 1);
    img.save(&img_path).expect("save PNG");

    let mut config = Config::default();
    config.limits.max_image_dimension = 100;

    let processor = ImageProcessor::new(&config);
    let result = processor.process(img_path.as_path()).await;

    assert!(
        result.is_ok(),
        "image at exact dimension limit should succeed, got: {result:?}"
    );
    let result = result.unwrap();
    assert_eq!(result.width, 100);
    assert_eq!(result.height, 1);
}

// ---------------------------------------------------------------------------
// Boundary: image dimension one pixel over limit (F6)
// ---------------------------------------------------------------------------

#[tokio::test]
async fn test_image_dimension_one_over_limit() {
    let dir = tempfile::tempdir().expect("create temp dir");
    let img_path = dir.path().join("dim_over_limit.png");

    // Create image 1px over the dimension limit
    let img = image::RgbImage::new(101, 1);
    img.save(&img_path).expect("save PNG");

    let mut config = Config::default();
    config.limits.max_image_dimension = 100;

    let processor = ImageProcessor::new(&config);
    let result = processor.process(img_path.as_path()).await;

    match result {
        Err(PhotonError::Pipeline(PipelineError::ImageTooLarge {
            width,
            height,
            max_dim,
            ..
        })) => {
            assert_eq!(width, 101);
            assert_eq!(height, 1);
            assert_eq!(max_dim, 100);
        }
        other => panic!("expected ImageTooLarge, got: {other:?}"),
    }
}

// ---------------------------------------------------------------------------
// ProcessOptions: all skips enabled (F7)
// ---------------------------------------------------------------------------

#[tokio::test]
async fn test_process_with_all_skips() {
    let config = Config::default();
    let processor = ImageProcessor::new(&config);

    let options = ProcessOptions {
        skip_thumbnail: true,
        skip_perceptual_hash: true,
        skip_embedding: true,
        skip_tagging: true,
    };

    let result = processor
        .process_with_options(fixture("beach.jpg").as_path(), &options)
        .await
        .expect("processing with all skips should succeed");

    // Core pipeline still runs: decode, EXIF, content hash
    assert!(!result.content_hash.is_empty());
    assert!(result.width > 0);
    assert!(result.height > 0);
    assert!(result.file_size > 0);

    // All optional stages skipped
    assert!(result.thumbnail.is_none(), "thumbnail should be skipped");
    assert!(
        result.perceptual_hash.is_none(),
        "perceptual hash should be skipped"
    );
    assert!(result.embedding.is_empty(), "embedding should be empty");
    assert!(result.tags.is_empty(), "tags should be empty");
}

// ---------------------------------------------------------------------------
// ProcessOptions: selective skips (F7)
// ---------------------------------------------------------------------------

#[tokio::test]
async fn test_process_with_selective_skips() {
    let config = Config::default();
    let processor = ImageProcessor::new(&config);

    let options = ProcessOptions {
        skip_thumbnail: true,
        skip_perceptual_hash: false,
        skip_embedding: true,
        skip_tagging: false, // tagging depends on embedding → should produce no tags
    };

    let result = processor
        .process_with_options(fixture("beach.jpg").as_path(), &options)
        .await
        .expect("processing with selective skips should succeed");

    // Core fields always populated
    assert!(!result.content_hash.is_empty());
    assert!(result.width > 0);

    // Thumbnail skipped
    assert!(result.thumbnail.is_none(), "thumbnail should be skipped");

    // Perceptual hash NOT skipped
    assert!(
        result.perceptual_hash.is_some(),
        "perceptual hash should be generated"
    );

    // Embedding skipped → tags empty (no input for tagging)
    assert!(result.embedding.is_empty(), "embedding should be empty");
    assert!(
        result.tags.is_empty(),
        "tags should be empty without embedding"
    );
}
